---
title: "컴퓨터 기술 정리 - 2"
author: Hve
date: 2023-12-11 09:32:32 +0900
categories: ["학습", "이론"]
math: false
mermaid: false
tags: ["컴퓨터시스템"]
---

## 시스템 종류

### 범용 시스템

- 개인용 컴퓨터 (PC)
    - e(ex. )
- 서버 컴퓨터
    - 네트워크를 클라이언트 요청을 처리 (ex. 웹서버, 파일서버, DNS서버 등)
- 메인 프레임 (Main Frame)
    - 단말기를 통해 다수의 사용자가 작업가능한 범용 목적의 대용 컴퓨터
- 슈퍼 컴퓨터
    - 연구 목적으로 사용되는 초고속 컴퓨터
    - 단일 기계로는 가장 빠름

### 개인 휴대용 시스템

- 휴대폰
    - 플래시 메모리가 내장됨, Micro SD같은 소형 메모리 카드에도 데이터 저장
- IoT

### 네트워크 장비

네트워크 카드
- 컴퓨터 등의 기기들이 통신하는 데 쓰이는 하드웨어
- 랜 카드, 네트워크 어댑터, 네트워크 인터페이스 카드, 이더넷 카드 등으로도 불림

OSI 계층 1 (물리 계층) & OSI 계층 2 (데이터 링크)
- MAC 주소를 사용해, 낮은 수준의 주소 할당 시스템을 제공

MAC
- IEEE 표준에 근거해 각 네트워크 카드는 고유의 MAX주소를 네트워크 컨트롤러 제조사가 책입지고 할당

허브
- 이더넷 네트워크에 여러 대의 컴퓨터 네트워크 장비를 연결하는 장치
- 허브에 라우터나 Layer3 스위치 등의 장비가 연결되면 이를 통해 높은 계층의 네트워크(WAN, MAN)과 연결이 가능해짐

스위치
- 네트워크 단위를 연결하는 통신장비
- LAN-LAN 연결 또는 LAN-WAN 연결하기 위한 인터넷 네트워킹 장비

침입차단 시스템
- 서로 다른 네트워크를 지나는 데이터를 허용하거나 거부하거나 검열, 수정하는 하드웨어나 소프트웨어 장치

침입탐지시스템 (IDS)
- 시스템에 대한 원치않는 조작 탐지
- 전통적인 방화벽이 탐지할 수 없는 모든 종류의 악의적인 네트워크 트래픽 및 컴퓨터 사용을 탐지하기 위해 필요
- 여러 구성요소로 이루어짐
    - 센서 : 보안 이벤트 발생
    - 콘솔 : 이벤트 모니터링, 센서 제어 및 경계
    - 중앙 엔진 : 센서에 의해 기록된 이벤트를 DB 기록, 시스템 규칙을 사용해 수신된 보안 이벤트로부터 경고 생성

### 임베디드 시스템

- 사무기기
    - 복사기, 스캐너 등
    - 이러한 기기 내부에는 소형 컴퓨터 구조와 같은 하드웨어 운영체제 내장되며 데이터가 저장되는 메모리가 존재
- 멀티미디어 기기
    - 캠코더, 카메라, CCRTV 등
    - 내부적으로 플래시 메모리를 탑재하나 영상이나 사진데이터는 별도의 메모리 카드, 하드 등에 저장됨

## 하드디스크

### 하드디스크의 구조

![IMAGE](/assets/img/noteforensic/01.png)

디지털 신호의 기록은 자기장의 밀도 변화를 이용해 기록
- 밀도 변화를 측정하는 헤드(head)가 플래터 위의 일정한 간격으로 지나는 동안 자기장의 극성의 변화를 확인하여 정보를 읽는다

대기 시간
- access time(response time) : 
- seek time : 슬라이더가 
- transfer time : 
- rotational latency time

*WIP*

### 하드디스크 I/O 작업

순차적 I/O
- 디스크의 인접한 데이터의 엑세스
- 트랙간 탐색 시간이 빨라 성능이 높음

랜덤 I/O
- 디스크의 서로 다른 부분으로 부터 엑세스
- 헤드 이동이 발생해 성능 감소

엘리베이터 정렬
- 랜덤 I/O 동작이 발생하면, 성능이 저하됨
- RAID 컨트롤러는 임의 탐색을 보다 효과적으로 처리하기 위해 엘리베이터 정렬 지원
- 가장 가까운 트랙부터 처리

IO성능 향상을 위해 디스크 컨트롤러에는 컨트롤러 캐쉬가 존재
- 컨트롤러는 데이터를 캐쉬로 기록하고 운영체제에 I/O 완료를 알리고 비동기로 디스크에 기록 (쓰기 성능 향상)
- 대량의 데이터 요청시 요청된 데이터 외 다음 데이터도 곧 읽힐 것이라 예상하고 다음 데이터의 일부를 같이 가져가는 작업 수행

## 디스크 팩

### 디스크 팩

![IMAGE](/assets/img/noteforensic/25.png)

디스크 팩
- 데이터를 영구적으로 보존 할 수 있는 기록 매체
- 전원이 공급되지 않아도 소멸하지 않는 비휘발성 특징을 가짐

관련 용어

1. 섹터 (sector)
    - 물리적으로 디스크 시스템에 데이터가 저장되는 단위
2. 트랙 (track)
    - 디스크 선반의 한 면(surface)에서 중심으로부터 같은 거리에 있는 섹터의 집합
    - 즉, 한 트랙은 여러 섹터로 구성됨
3. 디스크 원반 (platter)
    - 자성체를 입힌 원판에 자성 물질을 입혀 데이터를 읽고 쓰도록 만든 장치
    - 위 아래로 두개의 표면(surface)로 구성됨
4. 표면 (surface)
    - 디스크 양 면에 하나 씩 있음
5. 디스크 팩
    - 여러 디스크 원반을 같은 중심축에 쌓아놓은 것을의미
6. 실린더 (cylinder)
    - 하나의 디스크 팩에서 같은 반지름을 같는 트랙의 집합
    - 일반적으로 대량의 데이터를 순차 쓰기시 실린더 단위로 저장하게 된다

### 디스크 드라이브

디스크 드라이브
- 디스크 팩에 데이터를 기록하거나 기록된 데이터를 판독하는 장치

구성 장치
- 스핀들(spindle), 붐(boom), 암(arm) 헤드(head)

스핀들(spindle)
- 디스크 팩을 고정, 회ㅈ전축 역할

헤드(head)
- 데이트 판독 및 기록

암(arm)
- 헤드 지탱

붐(boom)
- 암과 헤드 지탱
- 헤드가 읽을 수 있도록 위치 이동

### 디스크의 물리적 주소

디스크 시스템에서 데이터 전송 단위는 물리적으로 섹터 단위이다

하나의 섹터를 정확히 지정하기 위해 다음이 필요
- 실린더 번호 (트랙 번호)
- 표면 번호
- 섹터 번호

![IMAGE](/assets/img/noteforensic/02.png)

디스크 시스템에서는 대량의 데이터를 순차적으로 저장할 때 실린더 단위로 저장한다

따라서, 실린더 딘위로 주소가 증가하도록 구성하려면 (a) 방법으로 구성해야 하며 (a)가 일반적인 주소 형태로 사용된다

### 디스크 접근 시간

- 탐색시간
- 회전 지역 시간
- 데이터 전송 시간

디스크 시스템에서 데이터 접근 시간이란 위 세가지를 모두 더한것을 말한다

### 디스크 주소 지정 기법

디스크의 물리적 주소는 (실린더 번호, 표면 번호, 섹터 번호)의 세 쌍으로 구성됨
- 이에 의해 해당 디스크 팩에서의 한 섹터를 유일하게 결정하게 됨
- 그러나 이 방법은 복잡하므로 간단한 방법을 사용함

논리적 상대 주소 표현법
- 디스크 시스템 측의 데이터 전체를 블럭들의 나열로 보고 각 블럭에 대해 블럭 번호를 부여하여 접근

### 디스크 분할

하드디스크의 드라이브나 메모리의 기억공간을 `파티션`이라는 별도의 데이터 영역으로 분할해 여러개로 인식하게 하는 것을 말한다

마스터 부트 레코드 (Master Boot Record, MBR)
- 컴퓨터를 실행했을 때, BIOS가 초기 부트 프로그램을 읽어올 수 있는 곳이 어딘가 있어야 한다
- 이 정보를 저장하는 장소를 MBR, 또는 부트 섹터라고 부른다
- MBR은 항상 실린더 0, 헤드 0, 섹터 1에 위치해 있다

마스터 파티션 테이블 (Mater Partition Table)
- 이 하드 디스크 드라이브에 포함된 파티션에 대한 설명이 저장됨
- 마스터 파티션 테이블에는 파티션 정보 공간이 4개만 존재
- 부가적인 파티션은 primary partition중 하나에 링크도니 논리 파티션
- 파티션 중 하나는 active로 표시됨 : 컴퓨터가 부팅을 위해 사용하는 것을 가르킴
- 4개 파티션중 하나는 확장 파티션 (Extended partition)으로 정할 수 있음
    - 이 파티션은 여러개의 논리 파티션으로 세분가능

GUID 파티션 테이블 (GUID Partition Table, GPT)
- 물리적인 하드 디스크에 대한 파티션 테이블 레이아웃 표준, 대부분 최신 운영체제에서 지원
- 기존 MBR 파티션 테이블의 제한 때문에 새로운 파티션 테이블 형식이 개발됨
- 하드 디스크의 주소 지정 차이
    - 물리적 주소(실린더헤드섹터,CHS) 대신 논리블록 주소지정(LBA) 사용
- 디스크 파티션 크기 제한 차이
    - MBR의 경우 2.2TB
    - GPT의 경우 9.4ZB

---

# part2

## 파일

### 파일 유형

- 텍스트 파일
- 이진 파일
    - 이진 파일 형식은 문자열로 해석될 수 있는 부분을 포함하고 있다

### 파일 선별

- 사용자는 확장자를 통해 파일의 종류를 식별
- 운영체제나 응용 소프트웨어는 종류에 따라 차이 존재
    - 동일하게 식별하거나
    - 파일의 서명 또는 파일 내용을 참조

파일 시그니처
- 파일의 시작 또는 끝에 배치된 2-4Bytes 정도의 고유한 값

### 파일의 상태 정보

모든 파일은 파일의 실질적인 데이터 외에도 그 파일에 대한 상태 정보를 함께 저장
- 이름, 종류, 크기, 생성 시간 등

운영체제에 따라 파일의 상태 정보들은 디렉토리에 저장되거나, 별도의 공간을 배정해 저장하기도 한다

### 파일 구성

파일 구성
- 데이터는 레코드 형태로 구성
- 각 레코드는 연관된 데이터 항목으로 구성
- 각 항목은 여러 바이트로 구성, 레코드의 특정 필드에 해당
- 데이터 타입
    - 프로그래밍에서 사용하는 정수, 실수 등의 수치형과 고정/가변길이 문자열, 시간 등
    - 이미지, 비디오 등 비구조적 데이터 타입 존재 : BLOB이라고 한다

하나의 파일은 여러 개의 레코드로 구성, 대부분의 경우 한 파일내 모든 레코드는 같은 레코드 타입을 가진다
- 파일내 모든 레코드의 크기가 같다면 : 고정길이
    - 이 경우 레코드는 같은 필드를 가지며, 필드 길이는 고정됨
- 파일내 레코드를 구성하는 필드의 길이가 서로 다르거나, 다중값을 가지는 경우 : 가변 길이
    - 각 레코드는 가변 길이 필드에 대한 값을 가지지만, 정확한 길이를 알지 못함

### 블록킹

디스크-주기억장치 간 데이터 전송 단위는 하나의 블록
- 한 파일의 레코드를 디스크 블록에 할당하여야 함
- 블록의 크기(B)가 레코드의 크기(R)보다 크다면 (B > R)
    - 각 블록에 Bf = B/R 개의 레코드 저장 가능
    - Bf를 블로킹 인수(Blocking factor)
    - B/R의 나머지 값은, 각 블록에서 사용하지 않는 여유 공간이 됨

- r개의 레코드로 구성된 파일이 필요로 하는 블록의 수는?
    - b = r/Bf
    - 예시) 레코드 크기(R)가 100바이트 레코드 개수(r)가 10,000개, 블록 크기를 1024바이트라고 한다면,
        - Bf = 1024/100 = 10
        - 필요한 블록의 갯수(b)는 r/Bf = 10000/10 = 1000개
- 블록킹의 장단점
    - I/O 시간 감소
        - 디스크에서 주기억 장치 버퍼로의 데이터 전송 횟수를 줄이기 위함
        - 블록의 크기가 커질수록 전송 횟수는 적어짐
    - 단편화
        - 블럭의 크기는 버퍼의 크기에 제한을 받음. 불필요한 공간 낭비 초래

### 레코드 저장 방식

- 비신장(unspanned) 조직
    - 레코드들을 디스크 블록에 저장할 때, 레코드 크기 < 각 블록 크기인 경우
    - 각 레코드는 이미 알려진 위치에서 시작하므로, B > R인 고정길이 레코드에 사용됨. 블록은 사용하지 않는 여유공간을 가짐
- 신장(spanned) 조직
    - 블록의 사용하지 않는 공간을 활용하기 위해 레코드를 여러 블록에 걸쳐 저장할 수 있다
    - B < R인 경우 사용됨
- 파일 내 레코드를 접근하는 프로그램이 필요로 하는 정보를 파일 헤더에 저장
    - 헤더는 블록들의 디스크 상 주소에 대한 정보와 레코드 형식에 대한 정보 유지
    - 고정길이 비신장 레코드의 경우 
        - 필드 크기, 필드의 순서 저장
    - 가변길이 신장 레코드의 경우
        - 필드유형코드, 분리특수문자, 레코드 타입 등 저장

### 버퍼링

- 디스크에서 검색된 블록을 주기억장치로 전송시 전송 속도 높이기 위함
    - 주기억장치 내 여러 개의 버퍼를 예약해 사용
- 하나의 버퍼를 판독/기록하는 동안 CPU는 다른 버퍼 내 데이터 처리
    - 이는 CPU처리와 병렬로 주기억장치-디스크간 데이터블록을 전송할 수 있기 때문
- 이중 버퍼링, 큐(Queue)
    - 디스크 블록이 주기억장치로 전송되면 CPU는 해당 블록을 처리
    - 동시에, 디스크 I/O 처리기는 다음 블록을 판독 후 다른 버퍼에 전송하는 기법
    - 이중 버퍼링을 통해 연속적인 디스크 블록 상 데이터를 판독/기록 시 첫번째 블록에 대한 탐색시간, 회전지연시간을 제거할 수 있다

## 파일 시스템 구조

### 논리적 구조

평면 디렉토리 구조
- 파일시스템 전체에 하나의 디렉토리만 존재하고 거기에 모든 파일을 저장하는 구조
- 모든 파일의 이름을 다르게 해야하는 문제
- 다중 사용자 환경에서 문제 커짐

2단계 디렉토리 구조
- 각 사용자마다 디렉토리 배정

계층 디렉토리
- 한 디렉토리 내 다른 디렉토리를 생성할 수 있음
- UNIX, MS-DOS, Windows 등 대부분 운영체제에서 채택

그래프 디렉토리 구조
- 계층 디렉토리 구조의 확장
- 임의의 디렉토리를 다른 디레고리와 연결되게 하는 방법

### 물리적 구조

디스크는 블록의 나열이므로 저장하는 방법의 차이 존재
- 연속할당 기법
    - 간단함
    - 공간관리 측면에서 비효율적
- 비연속 할당

디스크 상의 빈 공간을 확인하는 방법
- 비트 벡터 기법
    - 모든 데이터 블록에 대해 각 블록이 현재 사용중인지 아닌지를 표시하는 1비트 플래그를 사용
    - 이 비트 벡터는 커널의 파일시스템 측에서 유지 및 관리
- 연결 리스트 기법
    - 디스크 상 모든 빈 블록을 연결 리스트로 연결하고 첫번째 블록의 포인터만을 커널에서 유지
- 그룹화 기법
    - 각 빈 블록에서 n개의 빈 블록 번호를 저장
    - 이중 n-1개의 번호는 빈 블록의 번호이며, 나머지 하나는 다음 n개의 빈 블록 번호를 갖는 블록의 번호
    - 연결리스트 기법의 방법을 사용하나, 각 노드에 n개의 빈 블록 번호가 유지된다는 차이점
        - 따라서 연결리스트 기법에 비해 1/n 정도의 작은 노드를 가짐
- 카운팅 기법
    - 빈 공간을 블록 단위로 관리하는 대신, 연속된 빈 블록을 하나로 묶어 관리
    - 커널에서 빈 공간을 유지관리하는 테이블에 각 빈블록의 묶음과 묶음내 블록 수를 저장하여 효율성 증가
    - 연속할당 기법을 사용하는 시스템에서 효과적

### 파티션

파티션이란?
- 연속된 저장 공간을 하나 이상의 연속되고 독립된 영역으로 나누어 사용하도록 정의한 규역

![IMAGE](/assets/img/noteforensic/03a.png)

![IMAGE](/assets/img/noteforensic/03b.png)

단일 파티션과 다중 파티션 차이
- MBR의 존재여부

### 파티션과 볼륨

![IMAGE](/assets/img/noteforensic/04.png)

볼륨
- 운영체제가 사용가능한 섹터의 집합
- 물리적으로 연속된 공간에 상관없이 섹터의 집합
    - ex. 물리적으로 두개의 하드디스크를 묶어 하나의 볼륨으로 사용가능

파티션
- 반드시 연속된 섹터들로 구성되어야 한다는 차이

### MBR (Master Boot Record)

- 단일 파티션의 경우 VBR(Volume Boot Record)이 MBR 위치에 존재
- 다중 시스템의 경우, MBR이 실행되어 부팅가능한 VBR을 찾음

MBR 구조 (총 512Bytes)
- 부트코드 (446 Bytes)
- 파티션 테이블 (64 Bytes)
- 시그니쳐 (2 Bytes)

컴퓨터 부팅시 과정
- POST(Power On Self Test)
- MBR 호출
- MBR이 기록된 부트코드 수행

MBR 부트코드가 하는 일
- 부팅 가능한 파티션을 찾음
- 찾은 파티션의 VBR로 점프
- 부팅 가능한 파티션이 없을 경우
    - Invalid partition table
    - Error loading opertaion system
    - Missing operation system

*MBR 파티션 테이블* - 디지털포렌식시 중요한 부분
- 파티션 테이블은 총 64Bytes
- 16Bytes씩 총 4개의 파티션 정보(`파티션 엔트리`) 표현
- 파티션을 사용하지 않는다면 그부분은 0으로 채워짐
- 파티션을 하나만 사용할 경우 VBR만 존재해 파티션 테이블 또한 없다

![IMAGE](/assets/img/noteforensic/05.png)

파티션 엔트리 구조
- Boot Flag : 부팅 가능 여부
    - 부팅 가능시 0x80, 아니라면 0x00
- Starting CHS Address
    - CHS 모드로 표기하는 파티션 시작주소
    - 윈도우 2000이상부터 무시되는 값
- Partition Type
    - 파일시스템의 종류
        - NTFS : 0x07
        - FAT32 : 0x0C
- Ending CHS Address
- Staring LBA(Logical Block Address)
    - 하드디스크 한 섹터를 블록 단위로 논리적인 단위로 주소를 매겨 사용
- Size in Sector
    -  해당 파티션의 총 섹터 개수
    - LBA의 블록 하나는 512Bytes이므로, `Size in Sector` x 512시 파티션의 총 용량을 구할 수 있다

### 확장 파티션

MBR 영역에선 4개까지만 파티션 표현되며 4개 이상시 확장 파티션 구조를 사용

4개 이상 만들면, 자동으로 확장 파티션이 생성됨

구조
- Partition Type값이 0x05, 0x0F인 경우, 확장 파티션 구조
- LBA Addr 값은 확장 파티션에 대한 추가 정보를 가진 곳을 가르킴

![IMAGE](/assets/img/noteforensic/06.png)

- 주 파티션 테이블의 가장 마지막에 존재하는 엔트리를 `주 확장 파티션 엔트리`
- 부 파티션 테이블에 존재하는 확장 파티션 엔트리를 `부 확장 파티션 엔트리`
    - 부 파티션 테이블은 꼬리에 꼬리를 물고 계속해서 확장가능한 형태

### GPT

MBR과 차이
- MBR은 32bit 주소 사용, 즉 인식가능한 용량이 2TB
- GPT는 64bit 주소를 사용하여 9ZB까지 지원가능
- GPT는 128개의 주 파티션 테이블 생성
- 중요 데이터에 대한 복제본 저장해 복구 기능

![IMAGE](/assets/img/noteforensic/07.png)

구조
- GPT 디스크는 LEA 주소 사용
- (LBA 0)에 MBR 위치
    - Protective MBR
    - MBR 디스크만 인식하는 시스템이 오동작하는 것을 방지하기 위함
- (LEA 1) : GPT 헤더
- (LEA 2) : 파티션 테이블
- 그 뒤에는 파티션 정보가 저장됨
- (LEA n-1, LEA n) 백업

## 파일시스템 유형

exFAT
- NTFS가 자료구조 오버헤드 등으로 적절치 않는 경우 사용
- 볼륨 크기 16EB
- 파일 크기 128PB

![IMAGE](/assets/img/noteforensic/08.png)

## FAT

FAT 구조
- 예약된 영역 존재
- 2개의 FAT 영역이 존재하며 서로 백업 관계
    
![IMAGE](/assets/img/noteforensic/09.png)

FAT 영역엔 FAT 엔트리 할당
- FAT32는 32bit
- 각각의 엔트리는 같은 주소의 클러스터와 매칭
- 클러스터 할당여부에 따라 다른 값
    - 0x0 : 사용가능
    - 0x?FFF FFFF : 마지막 클러스터
    - 0xFFFF FFF7 : Bad Cluster
- FAT 엔트리 0번은 Media Type의 복사본 저장
- FAT 엔트리 1번은 파일시스템 불량 상태 저장

![IMAGE](/assets/img/noteforensic/10.png)

데이터 영역 (Data Area)
- 디렉터리 엔트리
    - 각 파일과 디렉터리마다 할당된 데이터 구조체
- 긴 파일명 디렉터리 엔트리
    - Attribute값이 0x0F라면, 긴 파일 이름 엔트리

## NTFS

NTFS
- 디스크 오류 복구
- 대용량 하드 지원 확장
- 사용 권한 및 암호화

### NTFS 구조

NTFS 구조
- 모든 데이터를 파일 형태로 관리
    - 파일시스템을 관리하기 위한 데이터 또한 데이터 영역의 파일 형태로 저장
    - 정형화된 볼륨 레이아웃이 존재하지 않음

![IMAGE](/assets/img/noteforensic/11.png)

![IMAGE](/assets/img/noteforensic/24.png)

- VBR 영역
    - NTFS에서 유일하게 위치가 고정된 영역
    - 볼륨의 첫번째 섹터에 위치
    - 운영체제 가동시 볼륨 인식을 위한 역할
    - 구조
        - 부트 섹터
        - NTLDR 위치 정보
        - 추가 부트코드

![IMAGE](/assets/img/noteforensic/12.png)

- MFT (Master File Table)
    - MFT Entry라는 구조체의 집합으로 구성
        - 각, 파일 디렉터리 정보 저장
    - 전체 파일, 디렉터리 개수가 늘어나면 MFT도 증가
        - 추가 할당 필요시 데이터영역에 추가로 할당됨

- MFT Entry
    - 볼륨에 저장된 모든 파일과 디렉터리 정보를 저장
    - 1개 Entry 사이즈는 1KB
        - MFT Entry Header
        - Attribute : 속성 저장, 한 Entry에 여러 Attribute가 저장될 수 있다

![IMAGE](/assets/img/noteforensic/13.png)

- MFT Entry
    - Attribute
        - 헤더와 내용 부분으로 나뉨
        - 헤더는 구조가 같지만 내용은 속성 종류에 따라 구조가 달라짐
        - Resident 방식
            - 속성 헤더 뒤에 내용이 붙음
        - Non-Resident
            - 속성의 내용이 너무 커서 MFT Entry에 다 담지 못할때 사용
            - 헤더 다음에 Cluster Run 구조체가 들어감
            - Cluster Run
                - Run data에 클러스터 위치와 길이가 표현됨
                - 여러 곳에 분산되었다면 Run data도 많아짐
            
![IMAGE](/assets/img/noteforensic/14.png)

- LCN, VCN
    - NTFS에서 사용하는 주소방식
    - LCN : 볼륨의 첫번째 클러스터 부터 차례로 지정됨 (중복이 없음)
    - VCN : 파일의 첫번째 클러스터 부터 차례로 지정됨
        - 볼륨 안에서는 중복이 존재

![IMAGE](/assets/img/noteforensic/15.png)

### NTFS 특징

특징
- 데이터 복구 기능
    - 트렌젝션 단위로 기록히므로 $LogFile 등을 열람해 복구 가능
- 암호화 기능
- ADS
- 압축
    - 파일시스템 단위 압축
    - 시스템 성능이 하락하므로 권장하지 않는 기능
- 디스크 쿼터
    - 사용자마다 디스크사용량 제한
- Sparse
    - 파일 내용이 0뿐이라면, 모두 저장하지않고 0이 기록되었다는 사실만 저장
    - $DATA 속성에만 적용됨
- 동적 Bad Sector 재할당
- 대용량 파일
    - 16TB 까지 사용

## UFS 파일시스템

UFS(Unix File System)
- 실린더 그룹(Cylinder group)을 이용하여 전체적인 파일시스템을 관리하게

![IMAGE](/assets/img/noteforensic/16.png)

- 부트 블록 : boot loader
- 슈퍼 블록 : 전체 디스크에 대한 정보가 저장됨
- 실린더 그룹
    - 슈퍼 블록의 복제본
        - 슈퍼 블록은 중요하므로 실린더 그룹마다 복제본을 가짐
    - 실린더 그룹 블록
        - 각 실린더에 저장하는 테이블
    - inode 테이블
        - 소유자 그룹, 접근 모드, 파일 형태 등에 대한 정보를 저장함
    - 데이터블록
        - 실제 데잍터가 저장되는 공간

UFS 사용자 특징
- 계층적 파일시스템
- 각 파일은 특정 소유자에게 소유, 원칙적으로 소유자만 파일 조작 가능
    - 특권 사용자는 모든 파일에 대한 권한을 가진다
    - SetUID를 통해 일반 사용자가 접근가능

UFS 구조적 특징
- 파일 할당시 블록을 기본단위로 하여 필요시 동적 할당
    - 하드디스크 상 연속적으로 있을 필요가 없다

실린더 시스템의 특징
- 블록 분산 감소
    - 파일시스템이 디렉터리와 그에 속한 파일을 실린더 그룹 내 할당함
- 파일 탐색시간 향상
    - 심각한 분산화가 일어나지 않으므로 빠른 시간내 탐색 가능
- 큰 파일의 실린더 그룹 독점 방지   
    - 큰 파일은 여러 실린더로 분산
        - 클러스터링 기법 추가해, 순차 읽기쓰기를 가능하도록 함

## EXT

![IMAGE](/assets/img/noteforensic/17.png)

EXT 구조
- 부트 섹터
- 블록 그룹
    - EXT에서 데이터를 저장하는 단위 (NTFS의 클러스터와 유사한 단위)

### 블록 그룹

![IMAGE](/assets/img/noteforensic/18.png)

블록 그룹
- Super Block
    - 블록 그룹의 가장 첫번째 위치, 블록 할당 정보 저장
    - NTFSdml VBR과 유사
    - 블록 하나의 크기, 전체 블록 개수, 각 블록 그룹당 블록 개수 등
    - 중요한 정보이므로 복사본을 가짐
- GDT (Group Descriptor Table)
    - 각 블록 그룹의 저장한 group descriptor가 모인 구조체
    - group descriptor 저장 정보
        - 블록 비트맵의 시작 주소
        - 아이노드 비트맵의 시작 주소
        - 디렉토리 개수 등
    - 즉, Super Block + GDT를 통해 파일 시스템의 전체적인 정보 저장
- 블록 비트맵 (Block Bitmap)
    - GDT의 크기가 정해지지 않았으므로 블록 비트맵 정보의 위치도 정해지지 않음
    - GDT에 블록 비트맵의 주소가 저장되어있다
    - 블록 그룹 안의 블록의 할당 현황 저장
        - 사용중이라면 1, 비어있다면 0
- 아이노드 테이블 (Inode Table)
    - 아이노드의 할당 현황을 저장
    - 아이노드란?
        - 파일시스템에 저장된 모든 파일, 디렉토리에 대한 메타 데이터 저장 구조체
            - 크기, 수정, 접근, 속성 변경 시간 등 저장
            - 파일 크기, 파일 모드, 저장시 필요 블록 수 등 저장
        - 실제 데이터 위치한 블록에 대한 포인터 저장
            - 직접 포인터 방식
            - 간접 포인터 방식
                - 가르키는 포인터는 위치 블록을 가르키고 위치블록이 다시 파일 블록을 가르킨다
- 데이터 블록 (Data Blocks)
    - 디렉토리 엔트리(Directory Entry)와 실제 데이터 내용이 저장되는 블록

### EXT4 특징

- 하위 호환성
    - EXT3과의 하위호환성 제공
- 시간 정밀도 및 범위 향상
- 파일 시스템 확장
    - EXT4의 최대 파일 크기는 16TB
- 익스텐트 (Extent)
    - 연속되는 블록 시퀀스 방식
        - 인접한 물리적 블록의 묶음
        - 대용량 파일 접근 성능 향상, 단편화 최소화
- 파일 레벨 사전 할당
- 블록 할당 지연
    - flush 전까지 디스크의 물리적 블록 할당을 지연
- 저널링
    - 작업중 시스템 오류 또는 전원 문제가 발생해도 일관성 유지
- 온라인 조각 모음